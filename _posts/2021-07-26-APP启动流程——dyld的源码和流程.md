
ç›¸å…³æ–‡ç« é“¾æ¥ï¼š[iOSåº”ç”¨å¯åŠ¨æµç¨‹åˆ†æä¹‹dyldè¿‡ç¨‹åˆæ¢](https://juejin.cn/post/6983320661590540325)
> ä¸Šä¸€ç¯‡æˆ‘ä»¬ä»‹ç»äº†å…³äºåº”ç”¨å¯åŠ¨çš„ä¸€äº›æ•´ä½“è¿‡ç¨‹çš„è®²è§£ï¼Œè¿˜æœ‰å…³äºdyldçš„ä¸€äº›ç®€å•ä»‹ç»ï¼Œè¿™ä¸€ç¯‡æ–‡ç« æˆ‘ä»¬å°±ç”¨ä¸€ä¸ªæ¢è·¯è€…çš„è§†è§’å»åˆ†ædyldçš„æºç å’Œæµç¨‹å§ï¼
# ä¸€ã€dyldåˆ†æå‰çš„å‡†å¤‡
## 1ã€æºç 
åœ°å€ï¼šhttps://opensource.apple.com/tarballs/dyld/

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/57b21ff499a64c5a80d3bef43d0da39c~tplv-k3u1fbpfcp-watermark.image)
## 2ã€å †æ ˆä¿¡æ¯
```c++
(lldb) bt
* thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 1.1
  * frame #0: 0x000000010ae80ecc APPå¯åŠ¨æµç¨‹åˆ†æ`+[ViewController load](self=ViewController, _cmd="load") at ViewController.m:18:1
    frame #1: 0x00007fff20181ff2 libobjc.A.dylib`load_images + 1439
    frame #2: 0x000000010ae94e2c dyld_sim`dyld::notifySingle(dyld_image_states, ImageLoader const*, ImageLoader::InitializerTimingList*) + 425
    frame #3: 0x000000010aea3ba5 dyld_sim`ImageLoader::recursiveInitialization(ImageLoader::LinkContext const&, unsigned int, char const*, ImageLoader::InitializerTimingList&, ImageLoader::UninitedUpwards&) + 437
    frame #4: 0x000000010aea1ec7 dyld_sim`ImageLoader::processInitializers(ImageLoader::LinkContext const&, unsigned int, ImageLoader::InitializerTimingList&, ImageLoader::UninitedUpwards&) + 191
    frame #5: 0x000000010aea1f68 dyld_sim`ImageLoader::runInitializers(ImageLoader::LinkContext const&, ImageLoader::InitializerTimingList&) + 82
    frame #6: 0x000000010ae9526b dyld_sim`dyld::initializeMainExecutable() + 199
    frame #7: 0x000000010ae99f56 dyld_sim`dyld::_main(macho_header const*, unsigned long, int, char const**, char const**, char const**, unsigned long*) + 4789
    frame #8: 0x000000010ae941c2 dyld_sim`start_sim + 122
    frame #9: 0x000000010bc97a88 dyld`dyld::useSimulatorDyld(int, macho_header const*, char const*, int, char const**, char const**, char const**, unsigned long*, unsigned long*) + 2093
    frame #10: 0x000000010bc95162 dyld`dyld::_main(macho_header const*, unsigned long, int, char const**, char const**, char const**, unsigned long*) + 1198
    frame #11: 0x000000010bc8f224 dyld`dyldbootstrap::start(dyld3::MachOLoaded const*, int, char const**, dyld3::MachOLoaded const*, unsigned long*) + 450
    frame #12: 0x000000010bc8f025 dyld`_dyld_start + 37
```
## 3ã€MachOåˆ†æå·¥å…·
å·¥å…·ï¼ˆ ä¸‰è€…éƒ½å¯ï¼Œæ¨è MachOView ï¼‰ï¼š Hopper Disassemblerã€MachOViewã€IDA64

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/05f07d0bd36545c391254d8315309a97~tplv-k3u1fbpfcp-watermark.image)

## 4ã€æµ‹è¯•å·¥ç¨‹å’ŒMachOæ–‡ä»¶
> ä¸‹é¢åˆ†åˆ«æ˜¯æµ‹è¯•å·¥ç¨‹å’Œç»è¿‡MachOViewåˆ†æçš„æµ‹è¯•å·¥ç¨‹å¯æ‰§è¡Œæ–‡ä»¶ç»“æ„ä¿¡æ¯ã€‚
![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d4b56789bcbf4f26a73624010d8ec33e~tplv-k3u1fbpfcp-watermark.image)
![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9d840226eed14ead95591010f2a40c19~tplv-k3u1fbpfcp-watermark.image)

# äºŒã€è¿›å…¥æºç åˆ†ææµç¨‹
## 1ã€dyldå…¥å£å‡½æ•° _dyld_start  
- æœç´¢æºç ä¸­çš„_dyld_startå‡½æ•°ï¼Œæˆ‘ä»¬è¿›å…¥åˆ°arm64ç¯å¢ƒä¸‹çš„æ±‡ç¼–ï¼Œè·Ÿè¸ªæµç¨‹ã€‚æ‹¿åˆ°ä¸‹ä¸€ä¸ªå‡½æ•° dyldbootstrap::start 

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/97b74b8ece8047d8bb645a9dc4a26afb~tplv-k3u1fbpfcp-watermark.image)

- ç„¶åæ ¹æ®dyldbootstrapæ‰¾åˆ°å‘½åç©ºé—´å’Œstartå‡½æ•°ï¼Œä»æºç ä¸Šåˆ†æï¼Œæ˜¯dyldçš„å‡†å¤‡è¿‡ç¨‹ã€‚


![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7ac6870fde94478c8165d1d125b4fe5c~tplv-k3u1fbpfcp-watermark.image)

> å…¶å®ä»¥ä¸Šéƒ½æ˜¯ä¸ºdyldçš„åŠ è½½åšå‡†å¤‡å·¥ä½œçš„ï¼Œåœ¨ç¯å¢ƒå’Œå…¶ä»–çš„æ¡ä»¶éƒ½å‡†å¤‡å®Œæ¯•åï¼Œå°±å¼€å§‹è¿›å…¥dyldçš„mainä¸­å¼€å§‹dyldçš„é“¾æ¥è¿‡ç¨‹ã€‚

##  2ã€uintptr_t  _main åˆ†æ
- ### 2.1 ä»£ç è·Ÿè¸ªåˆ°dyld.cppçš„mainå‡½æ•°ä¸­

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a12e70546b8e4c0b94941ae962149ea2~tplv-k3u1fbpfcp-watermark.image)
> æŸ¥çœ‹å’Œæ£€æµ‹è®¾ç½®dyldä¸Šä¸‹æ–‡éœ€è¦ä¼ å…¥çš„å‚æ•°ï¼ŒåŒ…æ‹¬å¯æ‰§è¡Œæ–‡ä»¶ã€å‚æ•°ã€ç³»ç»Ÿè¿è¡Œç¯å¢ƒï¼Œå¹³å°æ¶æ„ç­‰ã€‚æˆ‘ä»¬çœ‹åˆ°ç¨‹åºæ—¥å¿—æ‰“å°ï¼šdyld: launch startedï¼åˆ°è¿™é‡Œï¼Œdyldæ‰ç®—æ­£å¼å¼€å§‹ï¼
> 
> ç»§ç»­æŸ¥çœ‹å†…éƒ¨å®ç°ï¼Œå¯ä»¥è·Ÿè¸ªåˆ°ä»¥ä¸‹ä»£ç ï¼š

- ### 2.2 setContextçš„å†…éƒ¨å®ç°é€»è¾‘ï¼Œè®¾ç½®ä¸Šä¸‹æ–‡å†…å®¹
```c++

static void setContext(const macho_header* mainExecutableMH, int argc, const char* argv[], const char* envp[], const char* apple[])
{

      #pragma mark - åŠ è½½åº“æ–‡ä»¶
      
	gLinkContext.loadLibrary			= &libraryLocator;
	gLinkContext.terminationRecorder	= &terminationRecorder;
	gLinkContext.flatExportFinder		= &flatFindExportedSymbol;
	gLinkContext.coalescedExportFinder	= &findCoalescedExportedSymbol;
	gLinkContext.getCoalescedImages		= &getCoalescedImages;
	gLinkContext.undefinedHandler		= &undefinedHandler;
        
       #pragma mark - è·å–æ‰€æœ‰æ˜ å°„åœ°å€
       
        gLinkContext.getAllMappedRegions	= &getMappedRegions;
	gLinkContext.bindingHandler			= NULL;
	gLinkContext.notifySingle			= &notifySingle;
	gLinkContext.notifyBatch			= &notifyBatch;
	gLinkContext.removeImage			= &removeImage;
	gLinkContext.registerDOFs			= dyld3::Loader::dtraceUserProbesEnabled() ? &registerDOFs : NULL;
	gLinkContext.clearAllDepths			= &clearAllDepths;
	gLinkContext.printAllDepths			= &printAllDepths;
	gLinkContext.imageCount				= &imageCount;
	gLinkContext.setNewProgramVars		= &setNewProgramVars;
        
	#pragma mark - é“¾æ¥å…±äº«ç¼“å­˜ï¼Œè¯´æ˜å·²ç»è£…è½½é•œåƒå®Œæ¯•
        
        gLinkContext.inSharedCache			= &inSharedCache;
	gLinkContext.setErrorStrings		= &setErrorStrings;
#if SUPPORT_OLD_CRT_INITIALIZATION
	gLinkContext.setRunInitialzersOldWay= &setRunInitialzersOldWay;
#endif
	gLinkContext.findImageContainingAddress	= &findImageContainingAddress;
	gLinkContext.addDynamicReference	= &addDynamicReference;
#if SUPPORT_ACCELERATE_TABLES
	gLinkContext.notifySingleFromCache	= &notifySingleFromCache;
	gLinkContext.getPreInitNotifyHandler= &getPreInitNotifyHandler;
	gLinkContext.getBoundBatchHandler   = &getBoundBatchHandler;
#endif
	gLinkContext.bindingOptions			= ImageLoader::kBindingNone;
        
        #pragma mark - ç»‘å®šåŸºæœ¬ä¿¡æ¯
        
	gLinkContext.argc					= argc;
	gLinkContext.argv					= argv;
	gLinkContext.envp					= envp;
	gLinkContext.apple					= apple;
	gLinkContext.progname				= (argv[0] != NULL) ? basename(argv[0]) : "";
	gLinkContext.programVars.mh			= mainExecutableMH;
	gLinkContext.programVars.NXArgcPtr	= &gLinkContext.argc;
	gLinkContext.programVars.NXArgvPtr	= &gLinkContext.argv;
	gLinkContext.programVars.environPtr	= &gLinkContext.envp;
	gLinkContext.programVars.__prognamePtr=&gLinkContext.progname;
	gLinkContext.mainExecutable			= NULL;
	gLinkContext.imageSuffix			= NULL;
	gLinkContext.dynamicInterposeArray	= NULL;
	gLinkContext.dynamicInterposeCount	= 0;
	gLinkContext.prebindUsage			= ImageLoader::kUseAllPrebinding;
	gLinkContext.sharedRegionMode		= ImageLoader::kUseSharedRegion;
}

```

- ### 2.3 åŠ è½½å…±äº«ç¼“å­˜


![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1adf5fede0c74d348d3e23b41f163405~tplv-k3u1fbpfcp-watermark.image)
> è¿™é‡Œç•¥è¿‡äº†ä¸€äº›æ­¥éª¤ï¼Œåœ¨è®¾ç½®å®Œä¸Šä¸‹æ–‡ä¹‹åï¼Œç³»ç»Ÿè¿›è¡Œäº†ä¸€äº›è¿è¡Œåº“è·¯å¾„çš„åŠ è½½ã€dyldç›¸å…³æ–¹æ³•çš„æ£€æµ‹ã€æ—¥å¿—æ‰“å°ã€ç¼“å­˜å¼€å¯çŠ¶æ€ç­‰æ“ä½œã€‚

- ### 2.4 mapSharedCache 
```c++

static void mapSharedCache(uintptr_t mainExecutableSlide)
{
	dyld3::SharedCacheOptions opts;
	opts.cacheDirOverride	= sSharedCacheOverrideDir;
	opts.forcePrivate		= (gLinkContext.sharedRegionMode == ImageLoader::kUsePrivateSharedRegion);
#if __x86_64__ && !TARGET_OS_SIMULATOR
	opts.useHaswell			= sHaswell;
#else
	opts.useHaswell			= false;
#endif
	opts.verbose			= gLinkContext.verboseMapping;
    // <rdar://problem/32031197> respect -disable_aslr boot-arg
    // <rdar://problem/56299169> kern.bootargs is now blocked
	opts.disableASLR		= (mainExecutableSlide == 0) && dyld3::internalInstall(); // infer ASLR is off if main executable is not slid
	loadDyldCache(opts, &sSharedCacheLoadInfo);

	// update global state
	if ( sSharedCacheLoadInfo.loadAddress != nullptr ) {
		gLinkContext.dyldCache 								= sSharedCacheLoadInfo.loadAddress;
		dyld::gProcessInfo->processDetachedFromSharedRegion = opts.forcePrivate;
		dyld::gProcessInfo->sharedCacheSlide                = sSharedCacheLoadInfo.slide;
		dyld::gProcessInfo->sharedCacheBaseAddress          = (unsigned long)sSharedCacheLoadInfo.loadAddress;
		sSharedCacheLoadInfo.loadAddress->getUUID(dyld::gProcessInfo->sharedCacheUUID);
		dyld3::kdebug_trace_dyld_image(DBG_DYLD_UUID_SHARED_CACHE_A, sSharedCacheLoadInfo.path, (const uuid_t *)&dyld::gProcessInfo->sharedCacheUUID[0], {0,0}, {{ 0, 0 }}, (const mach_header *)sSharedCacheLoadInfo.loadAddress);
	}
}


bool loadDyldCache(const SharedCacheOptions& options, SharedCacheLoadInfo* results)
{
    results->loadAddress        = 0;
    results->slide              = 0;
    results->errorMessage       = nullptr;

#if TARGET_OS_SIMULATOR
    // simulator only supports mmap()ing cache privately into process
    return mapCachePrivate(options, results);
#else
    if ( options.forcePrivate ) {
        // mmap cache into this process only
        return mapCachePrivate(options, results);
    }
    else {
        // fast path: when cache is already mapped into shared region
        bool hasError = false;
        if ( reuseExistingCache(options, results) ) {
            hasError = (results->errorMessage != nullptr);
        } else {
            // slow path: this is first process to load cache
            hasError = mapCacheSystemWide(options, results);
        }
        return hasError;
    }
#endif
}

```
> è¿™é‡Œé€šè¿‡dyld3å»è¿›è¡Œäº†ä¸€ä¸ªåŠ¨æ€åŠ è½½ç¼“å­˜æ˜ å°„çš„è¿‡ç¨‹ï¼Œåƒç³»ç»Ÿå¸¸ç”¨çš„ä¸€äº›åº“ï¼Œå¦‚UIKitã€Foundationç­‰æ‰€æœ‰iOSåº”ç”¨ç¨‹åºéƒ½ä¼šç”¨åˆ°çš„åº“ï¼Œå¯ä»¥é€šè¿‡åŠ è½½å…±äº«ç¼“å­˜çš„æ–¹å¼ï¼Œå‡å°‘ipaåŒ…ä½“çš„å¤§å°ï¼ŒèŠ‚çœç³»ç»Ÿçš„å†…å­˜å¼€é”€ï¼Œå‡å°‘èµ„æºå†—ä½™é—®é¢˜ã€‚

##  3ã€dyldä¸»å‡½æ•°è°ƒç”¨è¿‡ç¨‹åˆ†æ


![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bc4807da08834c45914cb1f7a21a50c1~tplv-k3u1fbpfcp-watermark.image)
> ä»¥ä¸Šæ˜¯è·å–MachOå¯æ‰§è¡Œæ–‡ä»¶ä¿¡æ¯ï¼Œå¹¶é€šè¿‡dyldé“¾æ¥å™¨å­˜å‚¨ä»£ç ç­¾åä¿¡æ¯ã€‚

- ### 3.1 åŠ è½½å¯æ‰§è¡Œæ–‡ä»¶ä¿¡æ¯
```c++

#pragma mark - åŠ è½½å¯æ‰§è¡Œæ–‡ä»¶ä¿¡æ¯

static ImageLoaderMachO* instantiateFromLoadedImage(const macho_header* mh, uintptr_t slide, const char* path)
{
	// try mach-o loader
//	if ( isCompatibleMachO((const uint8_t*)mh, path) ) {
		ImageLoader* image = ImageLoaderMachO::instantiateMainExecutable(mh, slide, path, gLinkContext);
		addImage(image);
		return (ImageLoaderMachO*)image;
//	}
	
//	throw "main executable not a known format";
}


#pragma mark - ä¸ºå¯æ‰§è¡Œæ–‡ä»¶ï¼Œåˆ›å»ºé•œåƒ

// create image for main executable
ImageLoader* ImageLoaderMachO::instantiateMainExecutable(const macho_header* mh, uintptr_t slide, const char* path, const LinkContext& context)
{
	//dyld::log("ImageLoader=%ld, ImageLoaderMachO=%ld, ImageLoaderMachOClassic=%ld, ImageLoaderMachOCompressed=%ld\n",
	//	sizeof(ImageLoader), sizeof(ImageLoaderMachO), sizeof(ImageLoaderMachOClassic), sizeof(ImageLoaderMachOCompressed));
	bool compressed;
	unsigned int segCount;
	unsigned int libCount;
	const linkedit_data_command* codeSigCmd;
	const encryption_info_command* encryptCmd;
	sniffLoadCommands(mh, path, false, &compressed, &segCount, &libCount, context, &codeSigCmd, &encryptCmd);
	// instantiate concrete class based on content of load commands
	if ( compressed ) 
		return ImageLoaderMachOCompressed::instantiateMainExecutable(mh, slide, path, segCount, libCount, context);
	else
#if SUPPORT_CLASSIC_MACHO
		return ImageLoaderMachOClassic::instantiateMainExecutable(mh, slide, path, segCount, libCount, context);
#else
		throw "missing LC_DYLD_INFO load command";
#endif
}

```
> ä»¥ä¸Šæ“ä½œæ˜¯é€šè¿‡ImageLoaderåŠ è½½MachOå¯æ‰§è¡Œæ–‡ä»¶ï¼Œè·å–Headeræ–‡ä»¶

```c++

static bool hasCodeSignatureLoadCommand(const macho_header* mh)
{
	const uint32_t cmd_count = mh->ncmds;
	const struct load_command* const cmds = (struct load_command*)(((char*)mh)+sizeof(macho_header));
	const struct load_command* cmd = cmds;
	for (uint32_t i = 0; i < cmd_count; ++i) {
		if (cmd->cmd == LC_CODE_SIGNATURE) 
			return true;
		cmd = (const struct load_command*)(((char*)cmd)+cmd->cmdsize);
	}
	return false;
}

```
> ä»¥ä¸Šæ“ä½œæ˜¯è·å–MachOæ–‡ä»¶çš„LoadCommandå†…å®¹ï¼Œè·å–ä»£ç ç­¾åä¿¡æ¯ã€‚

- ### 3.2 åŠ è½½imagesã€runtimeã€cacheä¿¡æ¯åˆ°dyld_all_image_info

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f64913d5ef674d129cc5109d2e2c1132~tplv-k3u1fbpfcp-watermark.image)

- ### 3.3 åŠ è½½æ’å…¥åŠ¨æ€åº“

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0938a76475e940cfa812a1a62ef66990~tplv-k3u1fbpfcp-watermark.image)

- ### 3.4 æ’å…¥åŠ¨æ€åº“çš„æ–¹æ³• loadInsertedDylib
```c++

static void loadInsertedDylib(const char* path)
{
	unsigned cacheIndex;
	try {
		LoadContext context;
		context.useSearchPaths		= false;
		context.useFallbackPaths	= false;
		context.useLdLibraryPath	= false;
		context.implicitRPath		= false;
		context.matchByInstallName	= false;
		context.dontLoad			= false;
		context.mustBeBundle		= false;
		context.mustBeDylib			= true;
		context.canBePIE			= false;
		context.origin				= NULL;	// can't use @loader_path with DYLD_INSERT_LIBRARIES
		context.rpath				= NULL;
		
    #pragma mark - å¦‚æœå­˜åœ¨ï¼Œå°±åŠ è½½åŠ¨æ€åº“åˆ°æŒ‡å®šä½ç½®ï¼Œloadè¿‡ç¨‹çœç•¥...
             load(path, context, cacheIndex);
	}
	catch (const char* msg) {
		if ( gLinkContext.allowInsertFailures )
			dyld::log("dyld: warning: could not load inserted library '%s' into hardened process because %s\n", path, msg);
		else
			halt(dyld::mkstringf("could not load inserted library '%s' because %s\n", path, msg));
	}
	catch (...) {
		halt(dyld::mkstringf("could not load inserted library '%s'\n", path));
	}
}

```
- ### 3.5 é“¾æ¥ä¸»ç¨‹åº link main executable

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1dadeef20a5b410ea4e8c00a0b6c15ec~tplv-k3u1fbpfcp-watermark.image)
> link(sMainExecutable, ......)è¡¨ç¤ºä¸»ç¨‹åºé“¾æ¥è¿‡ç¨‹ï¼Œè¿™é‡Œå°±è¿›å…¥ä¸»ç¨‹åºé“¾æ¥è¿‡ç¨‹ã€‚

- ### 3.6 ä¸»ç¨‹åºé“¾æ¥åï¼Œè¿›è¡ŒåŠ¨æ€åº“æ’å…¥ï¼ˆç¬¦å·ä¿®æ­£æ“ä½œï¼‰

![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e725f1660df247ad903b8498e5399062~tplv-k3u1fbpfcp-watermark.image)

## 4ã€è°ƒç”¨æ‰€æœ‰åˆå§‹åŒ–å™¨ï¼Œè¿›è¡Œä¸»ç¨‹åºçš„åˆå§‹åŒ–

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8983545767fa4b2cb3ca4b020bcbd0d8~tplv-k3u1fbpfcp-watermark.image)

- ### 4.1 ä¸»å‡½æ•°æ‰§è¡Œçš„ä»£ç é€»è¾‘è·Ÿè¸ª
```c++

#pragma mark - initializeMainExecutable ä¸»å‡½æ•°

void initializeMainExecutable()
{
	// record that we've reached this step
	gLinkContext.startedInitializingMainExecutable = true;

#pragma mark - è¿è¡Œæ‰€æœ‰æ’å…¥åŠ¨æ€åº“çš„dyldåº“çš„åˆå§‹åŒ–å™¨
	// run initialzers for any inserted dylibs
	ImageLoader::InitializerTimingList initializerTimes[allImagesCount()];
	initializerTimes[0].count = 0;
	const size_t rootCount = sImageRoots.size();
	if ( rootCount > 1 ) {
		for(size_t i=1; i < rootCount; ++i) {
			sImageRoots[i]->runInitializers(gLinkContext, initializerTimes[0]);
		}
	}
	
#pragma mark - è¿è¡Œä¸»å‡½æ•°çš„åˆå§‹åŒ–å™¨å¹¶å–å‡ºæ‰€æœ‰ä¿¡æ¯
	// run initializers for main executable and everything it brings up 
	sMainExecutable->runInitializers(gLinkContext, initializerTimes[0]);
	
	// register cxa_atexit() handler to run static terminators in all loaded images when this process exits
	if ( gLibSystemHelpers != NULL ) 
		(*gLibSystemHelpers->cxa_atexit)(&runAllStaticTerminators, NULL, NULL);

	// dump info if requested
	if ( sEnv.DYLD_PRINT_STATISTICS )
		ImageLoader::printStatistics((unsigned int)allImagesCount(), initializerTimes[0]);
	if ( sEnv.DYLD_PRINT_STATISTICS_DETAILS )
		ImageLoaderMachO::printStatisticsDetails((unsigned int)allImagesCount(), initializerTimes[0]);
}

```

- ### 4.2 å­å‡½æ•° runInitializers

```c++

#pragma mark - å­å‡½æ•° runInitializers

void ImageLoader::runInitializers(const LinkContext& context, InitializerTimingList& timingInfo)
{
	uint64_t t1 = mach_absolute_time();
	mach_port_t thisThread = mach_thread_self();
	ImageLoader::UninitedUpwards up;
	up.count = 1;
	up.imagesAndPaths[0] = { this, this->getPath() };
	processInitializers(context, thisThread, timingInfo, up);
	context.notifyBatch(dyld_image_state_initialized, false);
	mach_port_deallocate(mach_task_self(), thisThread);
	uint64_t t2 = mach_absolute_time();
	fgTotalInitTime += (t2 - t1);
}

```
> è¿è¡Œåˆå§‹åŒ–å™¨ï¼Œè·å–é•œåƒå’Œé•œåƒè·¯å¾„ï¼Œæ‰§è¡Œåˆå§‹åŒ–è¿›è¡Œæ“ä½œã€‚

- ### 4.3 å­å‡½æ•° processInitializers
```c++

#pragma mark - å­å‡½æ•° processInitializers

void ImageLoader::processInitializers(const LinkContext& context, mach_port_t thisThread,
									 InitializerTimingList& timingInfo, ImageLoader::UninitedUpwards& images)
{
	uint32_t maxImageCount = context.imageCount()+2;
	ImageLoader::UninitedUpwards upsBuffer[maxImageCount];
	ImageLoader::UninitedUpwards& ups = upsBuffer[0];
	ups.count = 0;
	// Calling recursive init on all images in images list, building a new list of
	// uninitialized upward dependencies.
	for (uintptr_t i=0; i < images.count; ++i) {
		images.imagesAndPaths[i].first->recursiveInitialization(context, thisThread, images.imagesAndPaths[i].second, timingInfo, ups);
	}
	// If any upward dependencies remain, init them.
	if ( ups.count > 0 )
		processInitializers(context, thisThread, timingInfo, ups);
}
```
> è·å–ä¸Šä¸‹æ–‡å†…å®¹ä¸­çš„é•œåƒä¸åº“çš„ä¿¡æ¯ï¼Œæ£€æµ‹ä»–ä»¬çš„å‘ä¸Šå±‚çš„ä¾èµ–å…³ç³»ï¼Œå¦‚æœå­˜åœ¨ä¾èµ–åˆ™ç»§ç»­é€’å½’ï¼Œå¦åˆ™è¿›è¡Œæ‹¿åˆ°è¿™äº›ä¿¡æ¯è¿›è¡Œåˆå§‹åŒ–è¿‡ç¨‹ã€‚


- ### 4.4 å­å‡½æ•° recursiveInitialization ï¼ˆé€’å½’åˆå§‹åŒ–å™¨ï¼‰

```c++
#pragma mark - å­å‡½æ•° recursiveInitialization

void ImageLoader::recursiveInitialization(const LinkContext& context, mach_port_t this_thread, const char* pathToInitialize,
										  InitializerTimingList& timingInfo, UninitedUpwards& uninitUps)
{
	recursive_lock lock_info(this_thread);
	recursiveSpinLock(lock_info);

	if ( fState < dyld_image_state_dependents_initialized-1 ) {
		uint8_t oldState = fState;
		// break cycles
		fState = dyld_image_state_dependents_initialized-1;
		try {
			// initialize lower level libraries first
			for(unsigned int i=0; i < libraryCount(); ++i) {
				ImageLoader* dependentImage = libImage(i);
				if ( dependentImage != NULL ) {
					// don't try to initialize stuff "above" me yet
					if ( libIsUpward(i) ) {
						uninitUps.imagesAndPaths[uninitUps.count] = { dependentImage, libPath(i) };
						uninitUps.count++;
					}
					else if ( dependentImage->fDepth >= fDepth ) {
						dependentImage->recursiveInitialization(context, this_thread, libPath(i), timingInfo, uninitUps);
					}
                }
			}
			
			// record termination order
			if ( this->needsTermination() )
				context.terminationRecorder(this);

			// let objc know we are about to initialize this image
			uint64_t t1 = mach_absolute_time();
			fState = dyld_image_state_dependents_initialized;
			oldState = fState;
			context.notifySingle(dyld_image_state_dependents_initialized, this, &timingInfo);
			
			// initialize this image
			bool hasInitializers = this->doInitialization(context);

			// let anyone know we finished initializing this image
			fState = dyld_image_state_initialized;
			oldState = fState;
			context.notifySingle(dyld_image_state_initialized, this, NULL);
			
			if ( hasInitializers ) {
				uint64_t t2 = mach_absolute_time();
				timingInfo.addTime(this->getShortName(), t2-t1);
			}
		}
		catch (const char* msg) {
			// this image is not initialized
			fState = oldState;
			recursiveSpinUnLock();
			throw;
		}
	}
	
	recursiveSpinUnLock();
}

```
> åˆ©ç”¨é€’å½’æŸ¥æ‰¾åŠ è½½åˆ°dyldçš„é•œåƒï¼Œè¿›è¡Œåˆå§‹åŒ–æ“ä½œï¼Œç›´åˆ°å®Œæˆæ‰€æœ‰é•œåƒæ–‡ä»¶çš„åˆå§‹åŒ–ï¼Œæœªå®Œæˆåˆå§‹åŒ–çš„é•œåƒå’Œåº“æ–‡ä»¶æŠ›å‡ºå¼‚å¸¸ã€‚

- ### 4.5 å­å‡½æ•° doInitialization
```c++
#pragma mark - å­å‡½æ•° doInitialization

bool ImageLoaderMachO::doInitialization(const LinkContext& context)
{
	CRSetCrashLogMessage2(this->getPath());

	// mach-o has -init and static initializers
	doImageInit(context);
	doModInitFunctions(context);
	
	CRSetCrashLogMessage2(NULL);
	
	return (fHasDashInit || fHasInitializers);
}

```
> æ“ä½œæ˜¯æ‹¿åˆ°é“¾æ¥çš„å†…å®¹ï¼Œè¿›è¡Œåˆå§‹åŒ–æ“ä½œï¼ŒåŒ…å«æ“ä½œï¼šæ—¥å¿—æ‰“å°ã€MachOåˆå§‹åŒ–åçš„é•œåƒå’Œå‡½æ•°åˆå§‹åŒ–ï¼Œæœ€åè¿”å›ä¸€ä¸ªåˆå§‹åŒ–å’Œç»‘å®šçŠ¶æ€ã€‚
>
><br>
> ä¸»å‡½æ•°è°ƒç”¨è¿‡ç¨‹ä¸»è¦æè¿°äº†é€šè¿‡åŠ è½½dyldä¸­å·²ç»ç¼“å­˜çš„å…³äºimagesé•œåƒä¿¡æ¯ï¼Œé€šè¿‡ä¸æ–­çš„é€’å½’æŸ¥æ‰¾ï¼Œè¿›è¡Œåˆå§‹åŒ–çš„æ•´ä¸ªè¿‡ç¨‹ã€‚

- ### # 4.6 åˆå§‹åŒ–ä¸»ç¨‹åºæ€»ç»“ï¼š
- initializeMainExecutable:åˆå§‹åŒ–ä¸»ç¨‹åº,å†…éƒ¨ä¼šè°ƒç”¨å…¶ä»–è·Ÿé•œåƒrootImageçš„åˆå§‹åŒ–
- runInitializers: è¿›ä¸€æ­¥è°ƒç”¨processInitializers
- processInitializers:é€’å½’è°ƒç”¨é•œåƒçš„åˆå§‹åŒ–
- recursiveInitialization: è¿™é‡Œä¼šæ£€æµ‹ä¸€äº›ä¾èµ–ï¼Œå¹¶å°†å®ƒåˆå§‹åŒ–ï¼Œæ¥ç€å¼€å§‹doInitialization
- doInitialization:å¼€å§‹åˆå§‹åŒ–åŠ¨ä½œ,è¿™ä¼šè¿›è¡Œå„ä¸ªæ¨¡å—çš„åˆå§‹åŒ–æ“ä½œ_objc_initä¹Ÿæ˜¯åœ¨æ­¤è¿›è¡Œçš„

> è¯´åˆ°doInitializationä¸­çš„_objc_initï¼Œæˆ‘ä»¬å¯ä»¥è·Ÿè¸ªä¸‹ç›¸å…³æµç¨‹ï¼š
```c++

void _objc_init(void)
{
    static bool initialized = false;
    if (initialized) return;
    initialized = true;
    
    // fixme defer initialization until an objc-using image is found?
    environ_init();
    tls_init();
    static_init();
    runtime_init();
    exception_init();
    cache_init();
    _imp_implementationWithBlock_init();

    _dyld_objc_notify_register(&map_images, load_images, unmap_image);

#if __OBJC2__
    didCallDyldNotifyRegister = true;
#endif
}

```
> è¿™é‡Œåˆå›åˆ°äº†objcä¸­è°ƒç”¨initåˆå§‹åŒ–æ–¹æ³•ï¼Œå½¢æˆäº†ä¸€ä¸ªå®Œæ•´çš„é—­ç¯ã€‚

## 5ã€mainå‡½æ•°å…¥å£ 

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2f5e7cb770bc497ca4f9cc398ae50651~tplv-k3u1fbpfcp-watermark.image)
> æˆ‘ä»¬çœ‹åˆ°å…¥å£å‡½æ•°çš„å€¼ä»getEntryFromLC_MAIN ã€ main executableå¾—åˆ°ï¼Œç»§ç»­è·Ÿè¸ªdyldçš„æºç å…¥å£å‡½æ•°ï¼š

- ### 5.1 é‡æ–°å›åˆ°dyldæ±‡ç¼–æºç 
```c++

#if __arm64__ && !TARGET_OS_SIMULATOR
	.text
	.align 2
	.globl __dyld_start
__dyld_start:
	mov 	x28, sp
	and     sp, x28, #~15		// force 16-byte alignment of stack
	mov	x0, #0
	mov	x1, #0
	stp	x1, x0, [sp, #-16]!	// make aligned terminating frame
	mov	fp, sp			// set up fp to point to terminating frame
	sub	sp, sp, #16             // make room for local variables
#if __LP64__
	ldr     x0, [x28]               // get app's mh into x0
	ldr     x1, [x28, #8]           // get argc into x1 (kernel passes 32-bit int argc as 64-bits on stack to keep alignment)
	add     x2, x28, #16            // get argv into x2
#else
	ldr     w0, [x28]               // get app's mh into x0
	ldr     w1, [x28, #4]           // get argc into x1 (kernel passes 32-bit int argc as 64-bits on stack to keep alignment)
	add     w2, w28, #8             // get argv into x2
#endif
	adrp	x3,___dso_handle@page
	add 	x3,x3,___dso_handle@pageoff // get dyld's mh in to x4
	mov	x4,sp                   // x5 has &startGlue

	// call dyldbootstrap::start(app_mh, argc, argv, dyld_mh, &startGlue)
	bl	__ZN13dyldbootstrap5startEPKN5dyld311MachOLoadedEiPPKcS3_Pm
	mov	x16,x0                  // save entry point address in x16
#if __LP64__
	ldr     x1, [sp]
#else
	ldr     w1, [sp]
#endif
	cmp	x1, #0
	b.ne	Lnew

	// LC_UNIXTHREAD way, clean up stack and jump to result
#if __LP64__
	add	sp, x28, #8             // restore unaligned stack pointer without app mh
#else
	add	sp, x28, #4             // restore unaligned stack pointer without app mh
#endif


#pragma mark - ************************************
#pragma mark - ***********  ç¨‹åºå…¥å£     ************
#pragma mark - ************************************

#if __arm64e__
	braaz   x16                     // jump to the program's entry point
#else
	br      x16                     // jump to the program's entry point
#endif

```
> å¦‚ä¸Šé¢æ‰€ç¤ºï¼šæˆ‘ä»¬ç€é‡æ¥çœ‹dyldçš„æºç¨‹åºarm64ç»“æ„ä¸‹çš„æ‰§è¡Œï¼Œç¨‹åºæ‰§è¡Œåˆ°è¿™é‡Œï¼Œå½¢æˆäº†ä¸€ä¸ªå®Œæ•´çš„é—­ç¯ï¼Œæˆ‘ä»¬åœ¨x16å¯ä»¥æ‰¾åˆ°ç¨‹åºçš„å…¥å£ï¼Œé‚£ä¹ˆmain()å‡½æ•°åœ¨å“ªé‡Œå‘¢ï¼Ÿä¸‹é¢æ¥ç€çœ‹dyldçš„æ±‡ç¼–ï¼š

- ### 5.2 LC_MAINå‡½æ•°çš„æ‰§è¡Œè¿‡ç¨‹

```c++


#pragma mark - **********************************************
#pragma mark - ***** LC_MAINè°ƒèµ·main()å‡½æ•°çš„å…¥æ ˆæ“ä½œ    ********
#pragma mark - **********************************************

	// LC_MAIN case, set up stack for call to main()
Lnew:	mov	lr, x1		    // simulate return address into _start in libdyld.dylib
#if __LP64__
	ldr	x0, [x28, #8]       // main param1 = argc
	add	x1, x28, #16        // main param2 = argv
	add	x2, x1, x0, lsl #3
	add	x2, x2, #8          // main param3 = &env[0]
	mov	x3, x2
Lapple:	ldr	x4, [x3]
	add	x3, x3, #8
#else
	ldr	w0, [x28, #4]       // main param1 = argc
	add	x1, x28, #8         // main param2 = argv
	add	x2, x1, x0, lsl #2
	add	x2, x2, #4          // main param3 = &env[0]
	mov	x3, x2
Lapple:	ldr	w4, [x3]
	add	x3, x3, #4
#endif
	cmp	x4, #0
	b.ne	Lapple		    // main param4 = apple
#if __arm64e__
	braaz   x16
#else
	br      x16
#endif

```
> è‡³æ­¤ï¼Œæˆ‘ä»¬å·²ç»å®Œæˆäº†dyldä»ç¨‹åºåŠ è½½åˆ°è¿›å…¥mainå‡½æ•°çš„æ•´ä¸ªæµç¨‹çš„åˆ†æï¼Œä¸‹é¢å†æ•´ç†ä¸€ä¸‹æ•´ä½“çš„æ€è·¯å’Œé€»è¾‘ã€‚

# ä¸‰ã€æ€»ç»“

![dyld_startåˆ°mainå‡½æ•°.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/26b3da919c1543db9b71283cc6e468ea~tplv-k3u1fbpfcp-watermark.image)

> ç”±äºæ—¶é—´å’Œç²¾åŠ›å…³ç³»ï¼Œè¿™é‡Œåªæ•´ç†äº†å…³äºdyldä»ç¨‹åºåŠ è½½åˆ°è¿›å…¥mainå‡½æ•°çš„ç®€è¦åˆ†æè¿‡ç¨‹ï¼Œæ›´è¯¦ç»†çš„å†…éƒ¨æ‰§è¡Œé€»è¾‘ï¼Œä»¥æ€ç»´å¯¼å›¾çš„å½¢å¼æ”¾åœ¨æœ€åï¼
>
><br>
> iOSåº”ç”¨å¯åŠ¨æµç¨‹å’Œdyldçš„é“¾æ¥è¿‡ç¨‹æ˜¯è¿›è¡Œç¨‹åºè¿è¡Œå’ŒåæœŸç¨‹åºä¼˜åŒ–çš„å¼€ç«¯ï¼Œä¸€å®šæŠŠæ¡ä½å…¶ä¸­çš„æµç¨‹å’Œä¸€äº›å…³é”®çš„ç‚¹ï¼Œæ–¹èƒ½å¤Ÿåœ¨ä»¥åçš„å¼€å‘ä¸­ï¼Œåšå‡ºä½“éªŒå‡ºä¼—çš„ç¨‹åºï¼çŸ¥è¯†éœ€è¦ç²¾ç›Šæ±‚ç²¾ï¼ŒçŸ¥å…¶ç„¶çŸ¥å…¶æ‰€ä»¥ç„¶ï¼Œæ–¹èƒ½æœ‰æ‰€æˆé•¿ï¼

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0e924fbcb78d411889926c88ab3cd736~tplv-k3u1fbpfcp-watermark.image)
ğŸŒºæ›´å¤šå†…å®¹æœŸå¾…ä¸ä½ ä¸€èµ·åˆ†äº«ï¼Œå–œæ¬¢çš„è¯ï¼Œç‚¹ä¸ªèµç‚¹ä¸ªå…³æ³¨ï¼ŒæŒç»­ä¸ºæ‚¨åˆ›é€ å¥½çš„å†…å®¹ã€‚

